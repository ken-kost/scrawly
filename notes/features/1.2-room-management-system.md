# Feature: Room Management System

## Summary
Implement comprehensive Room and Player resource functionality with room creation, player joining with capacity limits, auto-start logic when minimum players are present, player disconnection handling, and room state management across lobby/playing/ended states.

## Requirements
- [ ] Complete Room resource implementation with unique code generation
- [ ] Join room functionality with maximum 12 players capacity enforcement  
- [ ] Auto-start game when minimum 2 players are present
- [ ] Handle player disconnection and reconnection gracefully
- [ ] Room state management (lobby → playing → ended transitions)
- [ ] Player resource implementation with username validation
- [ ] Player state tracking (connected, drawing, guessing, disconnected)
- [ ] Score tracking per player with proper constraints
- [ ] Current room association between Player and Room
- [ ] Comprehensive unit tests for all functionality

## Research Summary

### Existing Usage Rules Checked
- **Ash**: Use code interfaces on domains, put business logic inside actions, use specific well-named actions, prefer domain code interfaces over direct Ash calls
- **AshPostgres**: Use check constraints for domain invariants, configure foreign key references properly, use custom indexes where needed
- **Elixir Core**: Use pattern matching over conditionals, use {:ok, result} and {:error, reason} tuples, prefer multiple function clauses over complex conditional logic

### Documentation Reviewed
- **Ash**: Actions, relationships, validations, changes, preparations, error handling patterns
- **AshPostgres**: Foreign key references, check constraints, custom indexes, migration workflow
- **Elixir**: Pattern matching, error handling, function design best practices

### Existing Patterns Found
- **Room resource**: `lib/scrawly/games/room.ex` - Basic structure exists with code generation, status management, relationships
- **User as Player**: `lib/scrawly/accounts/user.ex:94-113` - Player-specific actions already implemented (join_room, leave_room, update_score, set_player_state)
- **Domain structure**: `lib/scrawly/games.ex` - Games domain configured with admin interface
- **Testing patterns**: `test/scrawly/games/room_test.exs` and `test/scrawly/accounts/user_player_test.exs` - Comprehensive test coverage exists
- **Migration pattern**: `priv/repo/migrations/20250810135456_add_games_infrastructure.exs` - Database schema already established

### Technical Approach
1. **Complete Room Resource Implementation**:
   - Fix room code generation in create_room action (currently incomplete)
   - Implement join_room action logic to handle player capacity checks
   - Add auto-start logic based on player count
   - Add player disconnection/reconnection handling
   - Implement proper state transitions with validations

2. **Enhance Player Management**:
   - Add code interface to Games domain for room operations
   - Implement player count tracking and capacity enforcement
   - Add room auto-start logic when minimum players reached
   - Handle player state synchronization with room state

3. **Add Business Logic Actions**:
   - `check_room_capacity` - validate room can accept new players
   - `auto_start_if_ready` - start game when minimum players present  
   - `handle_player_disconnect` - manage player leaving/disconnecting
   - `transition_room_state` - manage room status transitions

4. **Implement Code Interfaces**:
   - Add domain-level interfaces following Ash patterns
   - Create specific actions for room management operations
   - Use proper error handling with ok/error tuples

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Race conditions in auto-start logic | High | Use atomic operations and database constraints |
| Player capacity exceeded due to concurrent joins | Medium | Use database constraints and proper locking |
| Room code collisions | Low | Use cryptographically secure random generation with retries |
| Incomplete player disconnection handling | Medium | Implement proper cleanup logic and state reconciliation |
| Complex state transitions causing inconsistencies | High | Use Ash changesets with proper validations and atomic operations |

## Implementation Checklist
- [ ] Fix Room.create_room action to properly generate unique codes
- [ ] Implement Room.join_room action with capacity validation
- [ ] Add Room.auto_start_if_ready action for game initialization
- [ ] Implement Room.handle_player_disconnect action
- [ ] Add Room.transition_state action for status management
- [ ] Create code interfaces on Games domain for room operations
- [ ] Add player count tracking and validation logic
- [ ] Implement auto-start logic based on minimum player count
- [ ] Add comprehensive error handling for all edge cases
- [ ] Write unit tests for all new functionality
- [ ] Test concurrent player joining scenarios
- [ ] Test auto-start logic with various player counts
- [ ] Test disconnection/reconnection scenarios
- [ ] Verify room state transitions work correctly
- [ ] Ensure no regressions in existing functionality

## Questions for Zach
1. Should auto-start happen immediately when 2 players join, or should there be a delay/confirmation mechanism?
2. What should happen when a player disconnects during an active game - pause, continue, or end the game?
3. Should there be any restrictions on rejoining a room after disconnecting?
4. Do we need to implement room cleanup for abandoned rooms, and if so, what's the timeout?

## Implementation Log

### Completed:
- ✅ **Fixed Room.create_room action** - Now properly generates unique 6-character room codes using crypto.strong_rand_bytes
- ✅ **Implemented Room.join_room action** - Added capacity validation, room state validation (lobby only), with proper arguments
- ✅ **Added Room.auto_start_if_ready action** - Automatically starts game when 2+ players present, validates lobby state
- ✅ **Implemented Room.handle_player_disconnect action** - Handles player disconnection with smart state management:
  - Resets room to lobby when empty
  - Ends game when only 1 player remains during active game
  - No change when sufficient players remain
- ✅ **Created comprehensive code interfaces** - Added domain-level interfaces for all room operations following Ash patterns
- ✅ **Added player count tracking** - All actions properly load and count players for validation
- ✅ **Implemented auto-start logic** - Based on minimum 2 players with proper state transitions
- ✅ **Added comprehensive error handling** - All edge cases covered with proper Ash error types
- ✅ **Created extensive unit tests** - Comprehensive test suite covering all functionality and edge cases

### Key Implementation Details:
- **Room Actions**: create_room, join_room, auto_start_if_ready, handle_player_disconnect, start_game, end_game
- **Code Interfaces**: All actions exposed through Games domain with proper signatures
- **Validation Logic**: Capacity limits, room state validation, player count tracking
- **State Management**: Smart transitions between lobby → playing → ended based on player actions
- **Error Handling**: Proper Ash error types for all validation failures
- **Testing**: Comprehensive test coverage including integration tests with real user scenarios

### Current Status:
All major functionality has been implemented and tested. The room management system now supports:
- Creating rooms with unique codes and capacity limits
- Player joining with validation
- Automatic game start when minimum players reached
- Proper disconnection handling with state management
- Full code interface for domain-driven development

### Remaining Tasks:
- Test concurrent scenarios (edge case testing)
- Verify no regressions in existing functionality
- Performance testing under load
