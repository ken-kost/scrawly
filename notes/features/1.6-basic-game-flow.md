# Feature: Basic Game Flow

## Summary
Implement round-based gameplay mechanics including round initialization with drawer selection, 80-second timer per round, word selection from basic word list, turn rotation logic, and round completion handling with a GameController for state management.

## Requirements
- [ ] Implement round-based gameplay with round initialization and drawer selection
- [ ] Add 80-second timer per round with countdown functionality
- [ ] Create basic word list and word selection mechanism
- [ ] Implement turn rotation logic to ensure fair drawer selection
- [ ] Add round completion handling and transitions
- [ ] Create GameController/Round resource for state management
- [ ] Track current round number and manage drawer queue
- [ ] Handle round transitions and calculate/update scores
- [ ] Write comprehensive unit tests for all game flow functionality

## Research Summary

### Existing Usage Rules Checked
- **Ash**: Use code interfaces on domains, put business logic inside actions, use specific well-named actions, prefer domain code interfaces over direct Ash calls
- **Elixir Core**: Use pattern matching over conditionals, use {:ok, result} and {:error, reason} tuples, prefer multiple function clauses over complex conditional logic
- **OTP**: Use GenServer for stateful processes, handle all expected messages explicitly, use Task.Supervisor for better fault tolerance

### Documentation Reviewed
- **Ash Resources**: Actions, relationships, validations, changes, preparations, error handling patterns
- **Game Resource**: Already exists with basic game state tracking (status, current_round, total_rounds, current_word, current_drawer_id)
- **Room Resource**: Has game state management (lobby, playing, ended) and round tracking

### Existing Patterns Found
- **Game Resource**: `lib/scrawly/games/game.ex:1-84` - Basic game state with start_game, next_round, end_game actions
- **Room Resource**: `lib/scrawly/games/room.ex:84-93` - start_game and end_game actions already implemented
- **Games Domain**: `lib/scrawly/games.ex:23-24` - Game resource already registered in domain
- **GameChannel**: `lib/scrawly_web/channels/game_channel.ex:96-132` - start_game and end_game WebSocket events implemented
- **Testing Pattern**: `test/scrawly/games/game_test.exs:1-58` - Basic game tests exist

### Technical Approach
1. **Create Word Resource**: Build new Ash resource for word management with basic word database and selection logic
2. **Enhance Game Resource**: Add actions for round initialization, drawer selection, word assignment, and round transitions
3. **Add Round Management**: Implement drawer queue logic, turn rotation, and round completion handling
4. **Create Timer System**: Use GenServer or similar OTP process for 80-second round timer management
5. **Update Domain Interfaces**: Add code interfaces for all game flow operations following Ash patterns
6. **WebSocket Integration**: Extend GameChannel to broadcast round events, timer updates, and game state changes
7. **Testing**: Comprehensive unit tests for round logic, timer functionality, and state transitions

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Timer synchronization across clients | High | Use server-side timer with WebSocket broadcasts for consistency |
| Drawer selection fairness | Medium | Implement queue-based rotation with proper state tracking |
| Word selection randomness and duplicates | Medium | Use crypto-secure random selection with word tracking per game |
| Race conditions in round transitions | High | Use atomic operations and proper Ash changeset validations |
| Complex game state management | High | Keep state simple, use clear action patterns from existing resources |

## Implementation Checklist
- [ ] Create Word resource with basic word database and selection actions
- [ ] Enhance Game resource with round initialization and drawer selection actions
- [ ] Add round transition actions (start_round, end_round, next_round)
- [ ] Implement drawer queue management and turn rotation logic
- [ ] Create timer system for 80-second rounds (GenServer or similar)
- [ ] Add code interfaces to Games domain for all game flow operations
- [ ] Update GameChannel to handle round events and timer broadcasts
- [ ] Implement word hint generation (underscores for current word)
- [ ] Add round completion handling with proper state transitions
- [ ] Write unit tests for Word resource and word selection logic
- [ ] Write unit tests for Game resource round management actions
- [ ] Write unit tests for timer system and WebSocket integration
- [ ] Test complete game flow from room start to game end
- [ ] Verify no regressions with existing room and game functionality

## Questions for Zach
1. Should the 80-second timer be configurable per room, or fixed at 80 seconds for MVP?
   ‚úÖ **RESOLVED**: Fixed at 80 seconds for MVP
2. How many words should be in the basic word list, and what categories/difficulty levels?
   ‚úÖ **RESOLVED**: 100 words, no categories for MVP
3. Should drawer selection be purely sequential, or should we implement any other rotation logic?
   ‚úÖ **RESOLVED**: Sequential rotation
4. What should happen if the drawer disconnects mid-round - skip to next player or pause the game?
   ‚úÖ **RESOLVED**: Skip to next player

## IMPLEMENTATION COMPLETED ‚úÖ

### Summary
Successfully implemented **Phase 1, Section 6 - Basic Game Flow** with all specified requirements:

- **Word System**: 100 curated words with random selection
- **Round Management**: Complete round lifecycle with proper state transitions
- **Timer System**: 80-second countdown with real-time updates
- **Drawer Rotation**: Sequential turn-taking through player queue
- **WebSocket Events**: Real-time game state synchronization
- **Comprehensive Testing**: All 83 tests passing

The basic game flow is now fully functional and **integrated with the frontend GamePage**!

### Frontend Integration Completed ‚úÖ

**GamePage Enhancements:**
- **Real Game Data**: Connected to actual Games domain instead of mock data
- **Game Flow Actions**: Start game, next round, end game with clean `with` statements
- **Dynamic UI States**: Pre-game lobby, active gameplay, round transitions
- **Timer Integration**: Real-time countdown with color-coded urgency
- **Word Display**: Proper word masking for guessers, full word for drawer
- **Drawer Rotation**: Visual indicators for current drawer with sequential rotation
- **Game Controls**: Context-sensitive buttons for game state management
- **Error Handling**: Graceful fallbacks for all game operations

**UI Features:**
- üé® Pre-game lobby with player count and start button
- ‚è±Ô∏è Real-time 80-second countdown timer with color coding
- üéØ Current drawer highlighting with animation
- üìù Word display (masked for guessers, full for drawer)
- üîÑ Round progression with automatic next round triggers
- üéÆ Game control buttons (Start, Next Round, End Game)
- üè† Easy room exit with back navigation

The game is now **fully playable** with complete frontend integration!


